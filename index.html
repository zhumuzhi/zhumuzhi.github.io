<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="Signika/css?family=Roboto:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Oswald:300,300italic,400,400italic,700,700italic|Exo:300,300italic,400,400italic,700,700italic|Menlo:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="朱慕之's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="朱慕之's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朱慕之's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 朱慕之's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">朱慕之's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-首页"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-归档"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-标签"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/23/WKWebView/" itemprop="url">
                  WKWebView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-23T14:53:13+08:00" content="2016-May-Monday">
              2016-May-Monday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="WKWebView-API"><a href="#WKWebView-API" class="headerlink" title="WKWebView API"></a>WKWebView API</h2><p>WKWebView的头文件声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// webview 配置，具体看下面</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) WKWebViewConfiguration *configuration;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 导航代理 </span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;WKNavigationDelegate&gt; navigationDelegate;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用户交互代理</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;WK<span class="built_in">UIDelegate</span>&gt; <span class="built_in">UIDelegate</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 页面前进、后退列表</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WKBackForwardList *backForwardList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 默认构造器</span></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame configuration:(WKWebViewConfiguration *)configuration <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 已不再使用</span></span><br><span class="line">- (instancetype)initWithCoder:(<span class="built_in">NSCoder</span> *)coder <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 与UIWebView一样的加载请求API</span></span><br><span class="line">- (nullable WKNavigation *)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加载URL</span></span><br><span class="line">- (nullable WKNavigation *)loadFileURL:(<span class="built_in">NSURL</span> *)URL allowingReadAccessToURL:(<span class="built_in">NSURL</span> *)readAccessURL <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接加载HTML</span></span><br><span class="line">- (nullable WKNavigation *)loadHTMLString:(<span class="built_in">NSString</span> *)string baseURL:(nullable <span class="built_in">NSURL</span> *)baseURL;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接加载data</span></span><br><span class="line">- (nullable WKNavigation *)loadData:(<span class="built_in">NSData</span> *)data MIMEType:(<span class="built_in">NSString</span> *)MIMEType characterEncodingName:(<span class="built_in">NSString</span> *)characterEncodingName baseURL:(<span class="built_in">NSURL</span> *)baseURL <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 前进或者后退到某一页面</span></span><br><span class="line">- (nullable WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 页面的标题，这昆支持KVO的</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当前请求的URL，它是支持KVO的</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *URL;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 标识当前是否正在加载内容中，它是支持KVO的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, getter=isLoading) <span class="built_in">BOOL</span> loading;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当前加载的进度，范围为[0, 1]</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> estimatedProgress;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 标识页面中的所有资源是否通过安全加密连接来加载，它是支持KVO的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasOnlySecureContent;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当前导航的证书链，支持KVO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *certificateChain <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 是否可以招待goback操作，它是支持KVO的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canGoBack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 是否可以执行gofarward操作，支持KVO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canGoForward;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回上一页面，如果不能返回，则什么也不干</span></span><br><span class="line">- (nullable WKNavigation *)goBack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进入下一页面，如果不能前进，则什么也不干</span></span><br><span class="line">- (nullable WKNavigation *)goForward;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 重新载入页面</span></span><br><span class="line">- (nullable WKNavigation *)reload;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 重新从原始URL载入</span></span><br><span class="line">- (nullable WKNavigation *)reloadFromOrigin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 停止加载数据</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行JS代码</span></span><br><span class="line">- (<span class="keyword">void</span>)evaluateJavaScript:(<span class="built_in">NSString</span> *)javaScriptString completionHandler:(<span class="keyword">void</span> (^ __nullable)(__nullable <span class="keyword">id</span>, <span class="built_in">NSError</span> * __nullable error))completionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 标识是否支持左、右swipe手势是否可以前进、后退</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsBackForwardNavigationGestures;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自定义user agent，如果没有则为nil</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *customUserAgent <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在iOS上默认为NO，标识不允许链接预览</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsLinkPreview <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#if TARGET_OS_IPHONE</span></span><br><span class="line"><span class="comment">/*! @abstract The scroll view associated with the web view.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#if !TARGET_OS_IPHONE</span></span><br><span class="line"><span class="comment">// 标识是否支持放大手势，默认为NO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsMagnification;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 放大因子，默认为1</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> magnification;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据设置的缩放因子来缩放页面，并居中显示结果在指定的点</span></span><br><span class="line">- (<span class="keyword">void</span>)setMagnification:(<span class="built_in">CGFloat</span>)magnification centeredAtPoint:(<span class="built_in">CGPoint</span>)point;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">```` </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">## WKWebViewConfiguration配置</span></span><br><span class="line"></span><br><span class="line">	WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="meta">## WKPreferences偏好设置</span></span><br><span class="line"></span><br><span class="line">目前在iOS平台上偏好设置只有三个属性可以设置，如下：</span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="comment">// 设置偏好设置</span></span><br><span class="line">config.preferences = [[WKPreferences alloc] init];</span><br><span class="line"><span class="comment">// 默认为0</span></span><br><span class="line">config.preferences.minimumFontSize = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 默认认为YES</span></span><br><span class="line">config.preferences.javaScriptEnabled = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">// 在iOS上默认为NO，表示不能自动通过窗口打开</span></span><br><span class="line">config.preferences.javaScriptCanOpenWindowsAutomatically = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<h2 id="WKProcessPool内容处理池"><a href="#WKProcessPool内容处理池" class="headerlink" title="WKProcessPool内容处理池"></a>WKProcessPool内容处理池</h2><p>WKProcessPool并没有公开任何的属性或者方法，不需要配置：</p>
<pre><code>config.processPool = [[WKProcessPool alloc] init];
</code></pre><p>其实我们也没有必须去创建它。</p>
<h2 id="WKUserContentController内容交互控制器"><a href="#WKUserContentController内容交互控制器" class="headerlink" title="WKUserContentController内容交互控制器"></a>WKUserContentController内容交互控制器</h2><p>我们要通过JS与webview内容交互，就需要到这个类了，它的所有属性及方法说明如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读属性，所有添加的WKUserScript都在这里可以获取到</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;WKUserScript *&gt; *userScripts;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 注入JS</span></span><br><span class="line">- (<span class="keyword">void</span>)addUserScript:(WKUserScript *)userScript;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移除所有注入的JS</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllUserScripts;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加scriptMessageHandler到所有的frames中，则都可以通过</span></span><br><span class="line"><span class="comment">// window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</span></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="comment">// 比如，JS要调用我们原生的方法，就可以通过这种方式了</span></span><br><span class="line">- (<span class="keyword">void</span>)addScriptMessageHandler:(<span class="keyword">id</span> &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据name移除所注入的scriptMessageHandler</span></span><br><span class="line">- (<span class="keyword">void</span>)removeScriptMessageHandlerForName:(<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure>
<h2 id="WKUserScript"><a href="#WKUserScript" class="headerlink" title="WKUserScript"></a>WKUserScript</h2><p>在WKUserContentController中，所有使用到WKUserScript。WKUserContentController是用于与JS交互的类，而所注入的JS是WKUserScript对象。它的所有属性和方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS源代码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *source;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// JS注入时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) WKUserScriptInjectionTime injectionTime;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 只读属性，表示JS是否应该注入到所有的frames中还是只有main frame.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, getter=isForMainFrameOnly) <span class="built_in">BOOL</span> forMainFrameOnly;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化方法，用于创建WKUserScript对象</span></span><br><span class="line"><span class="comment">// source：JS源代码</span></span><br><span class="line"><span class="comment">// injectionTime：JS注入的时间</span></span><br><span class="line"><span class="comment">// forMainFrameOnly：是否只注入main frame</span></span><br><span class="line">- (instancetype)initWithSource:(<span class="built_in">NSString</span> *)source injectionTime:(WKUserScriptInjectionTime)injectionTime forMainFrameOnly:(<span class="built_in">BOOL</span>)forMainFrameOnly;</span><br></pre></td></tr></table></figure>
<h2 id="WKUserScriptInjectionTime"><a href="#WKUserScriptInjectionTime" class="headerlink" title="WKUserScriptInjectionTime"></a>WKUserScriptInjectionTime</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">WKUserScriptInjectionTime</span>) &#123;</span><br><span class="line">    <span class="type">WKUserScriptInjectionTimeAtDocumentStart</span>,</span><br><span class="line">    <span class="type">WKUserScriptInjectionTimeAtDocumentEnd</span></span><br><span class="line">&#125; <span class="type">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>
<p>它是一个枚举类型，只有在文档开始加载时注入和加载结束时注入。</p>
<h2 id="WKWebsiteDataStore存储的Web内容"><a href="#WKWebsiteDataStore存储的Web内容" class="headerlink" title="WKWebsiteDataStore存储的Web内容"></a>WKWebsiteDataStore存储的Web内容</h2><p>iOS9.0以后才能使用这个类。它是代表webview不同的数据类型，包括cookies、disk、memory caches、WebSQL、IndexedDB数据库和本地存储。</p>
<p>从这里看，要优化Webview好像可以通过它来实现，不过要求iOS9.0以上才能使用。现在6.0都没有抛弃的我，从来不能考虑这种最新的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认数据存储</span></span><br><span class="line">+ (WKWebsiteDataStore *)defaultDataStore;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回非持久化存储，数据不会写入文件系统</span></span><br><span class="line">+ (WKWebsiteDataStore *)nonPersistentDataStore;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 已经不可用</span></span><br><span class="line">- (instancetype)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 只读属性，表示是否是持久化存储</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, getter=isPersistent) <span class="built_in">BOOL</span> persistent;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取所有web内容的数据存储类型集，比如cookies、disk等</span></span><br><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)allWebsiteDataTypes;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取某些指定数据存储类型的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)fetchDataRecordsOfTypes:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)dataTypes completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;WKWebsiteDataRecord *&gt; *))completionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 删除某些指定类型的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)removeDataOfTypes:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)dataTypes forDataRecords:(<span class="built_in">NSArray</span>&lt;WKWebsiteDataRecord *&gt; *)dataRecords completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 删除某些指定类型的数据且修改日期是指定的日期</span></span><br><span class="line">- (<span class="keyword">void</span>)removeDataOfTypes:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)websiteDataTypes modifiedSince:(<span class="built_in">NSDate</span> *)date completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"> </span><br><span class="line">```` </span><br><span class="line">所有的dataTypes是下面这些系统所定义的：</span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeDiskCache <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeMemoryCache <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeOfflineWebApplicationCache <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeCookies <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeSessionStorage <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeLocalStorage <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeWebSQLDatabases <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line">WK_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> WKWebsiteDataTypeIndexedDBDatabases <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br></pre></td></tr></table></figure>
<h2 id="WKWebsiteDataRecord"><a href="#WKWebsiteDataRecord" class="headerlink" title="WKWebsiteDataRecord"></a>WKWebsiteDataRecord</h2><p>iOS9.0以后才可用。</p>
<p>website的数据存储记录类型，它只有两个属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常是域名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *displayName;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 存储的数据类型集</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *dataTypes;</span><br><span class="line">```` </span><br><span class="line"> </span><br><span class="line"><span class="meta">## WKSelectionGranularity选择粒度</span></span><br><span class="line"></span><br><span class="line">它表示在webview上选择内容的粒度，只有下面这两种类型：</span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, WKSelectionGranularity) &#123;</span><br><span class="line">    WKSelectionGranularityDynamic,</span><br><span class="line">    WKSelectionGranularityCharacter,</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">```` </span><br><span class="line">它是用于webview内容交互时选择内容的粒度类型设置。比如说，当使用WKSelectionGranularityDynamic时，而所选择的内容是单个块，这时候granularity可能会是单个字符；当所选择的web内容不限制于某个块时，granularity可能会是单个块。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">## WKNavigationDelegate</span></span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WKNavigationDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 决定导航的动作，通常用于处理跨域的链接能否导航。WebKit对跨域进行了安全检查限制，不允许跨域，因此我们要对不能跨域的链接</span></span><br><span class="line"><span class="comment">// 单独处理。但是，对于Safari是允许跨域的，不用这么处理。</span></span><br><span class="line"><span class="comment">// 这个是决定是否Request</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(WKNavigationActionPolicy))decisionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 决定是否接收响应</span></span><br><span class="line"><span class="comment">// 这个是决定是否接收response</span></span><br><span class="line"><span class="comment">// 要获取response，通过WKNavigationResponse对象获取</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(<span class="keyword">void</span> (^)(WKNavigationResponsePolicy))decisionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当main frame的导航开始请求时，会调用此方法</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当main frame接收到服务重定向时，会回调此方法</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当main frame开始加载数据失败时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当main frame的web内容开始到达时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当main frame导航完成时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当main frame最后下载数据失败时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这与用于授权验证的API，与AFN、UIWebView的授权验证API是一样的</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *__nullable credential))completionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当web content处理完成时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewWebContentProcessDidTerminate:(WKWebView *)webView <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="WKNavigationActionPolicy"><a href="#WKNavigationActionPolicy" class="headerlink" title="WKNavigationActionPolicy"></a>WKNavigationActionPolicy</h2><p>导航动作决定策略：</p>
 <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">WKNavigationActionPolicy</span>) &#123;</span><br><span class="line">    <span class="type">WKNavigationActionPolicyCancel</span>,</span><br><span class="line">    <span class="type">WKNavigationActionPolicyAllow</span>,</span><br><span class="line">&#125; <span class="type">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>
<p>它是枚举类型，只有Cancel和Allow这两种。设置为Cancel就是不允许导航，就不会跳转链接。</p>
<h2 id="WKNavigationResponsePolicy"><a href="#WKNavigationResponsePolicy" class="headerlink" title="WKNavigationResponsePolicy"></a>WKNavigationResponsePolicy</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, WKNavigationResponsePolicy) &#123;</span><br><span class="line">    WKNavigationResponsePolicyCancel,</span><br><span class="line">    WKNavigationResponsePolicyAllow,</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line">```` </span><br><span class="line"><span class="meta">## WKNavigationResponse</span></span><br><span class="line"></span><br><span class="line">WKNavigationResponse是导航响应类，通过它可以获取相关响应的信息：</span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="built_in">NS_CLASS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WKNavigationResponse</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 是否是main frame</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, getter=isForMainFrame) <span class="built_in">BOOL</span> forMainFrame;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取响应response</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURLResponse</span> *response;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 是否显示MIMEType</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canShowMIMEType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">```` </span><br><span class="line">只有接收响应与不接收响应两种。</span><br><span class="line"></span><br><span class="line"><span class="meta">## WKNavigationAction</span></span><br><span class="line"></span><br><span class="line">WKNavigationAction对象包含关于导航的action的信息，用于make policy decisions。它只有以下几个属性：</span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="comment">// 正在请求的导航的frame</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) WKFrameInfo *sourceFrame;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 目标frame，如果这是新的window，它会是nil</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) WKFrameInfo *targetFrame;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 导航类型，如下面的小标题WKNavigationType</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) WKNavigationType navigationType;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 导航的请求</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line"> </span><br><span class="line">```` </span><br><span class="line"> </span><br><span class="line"><span class="meta">## WKNavigationType</span></span><br><span class="line"></span><br><span class="line">WKNavigationType类型是枚举类型，它的可选值如下:</span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, WKNavigationType) &#123;</span><br><span class="line"><span class="comment">// 链接已经点击</span></span><br><span class="line">    WKNavigationTypeLinkActivated,</span><br><span class="line">    <span class="comment">// 表单提交</span></span><br><span class="line">    WKNavigationTypeFormSubmitted,</span><br><span class="line">    <span class="comment">// 前进、后退</span></span><br><span class="line">    WKNavigationTypeBackForward,</span><br><span class="line">    <span class="comment">// 重新载入</span></span><br><span class="line">    WKNavigationTypeReload,</span><br><span class="line">    <span class="comment">// 表单重新提交</span></span><br><span class="line">    WKNavigationTypeFormResubmitted,</span><br><span class="line">    <span class="comment">// 其它</span></span><br><span class="line">    WKNavigationTypeOther = <span class="number">-1</span>,</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line">```` </span><br><span class="line"><span class="meta">## WKUIDelegate</span></span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WKUIDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建新的webview</span></span><br><span class="line"><span class="comment">// 可以指定配置对象、导航动作对象、window特性</span></span><br><span class="line">- (nullable WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// webview关闭时回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidClose:(WKWebView *)webView <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用JS的alert()方法</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用JS的confirm()方法</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> result))completionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用JS的prompt()方法</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(<span class="built_in">NSString</span> *)prompt defaultText:(nullable <span class="built_in">NSString</span> *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> * __nullable result))completionHandler;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">```` </span><br><span class="line"><span class="meta">## WKBackForwardList</span></span><br><span class="line"></span><br><span class="line">WKBackForwardList表示webview中可以前进或者后退的页面列表。其声明如下：</span><br><span class="line"></span><br><span class="line">```` </span><br><span class="line"><span class="built_in">NS_CLASS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WKBackForwardList</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当前正在显示的item（页面）</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WKBackForwardListItem *currentItem;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 后一页，如果没有就是nil</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WKBackForwardListItem *backItem;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 前一页，如果没有就是nil</span></span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WKBackForwardListItem *forwardItem;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据下标获取某一个页面的item</span></span><br><span class="line">- (nullable WKBackForwardListItem *)itemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可以进行goback操作的页面列表</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;WKBackForwardListItem *&gt; *backList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可以进行goforward操作的页面列表</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;WKBackForwardListItem *&gt; *forwardList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="WKBackForwardListItem"><a href="#WKBackForwardListItem" class="headerlink" title="WKBackForwardListItem"></a>WKBackForwardListItem</h2><p>页面导航前进、后退列表项：</p>
<pre><code>NS_CLASS_AVAILABLE(10_10, 8_0)
@interface WKBackForwardListItem : NSObject

// 该页面的URL
@property (readonly, copy) NSURL *URL;

// 该页面的title
@property (nullable, readonly, copy) NSString *title;

// 初始请求该item的请求的URL
@property (readonly, copy) NSURL *initialURL;

@end
</code></pre><p> 参考：<a href="http://www.henishuo.com/wkwebview-objc/" target="_blank" rel="external">API</a> <a href="http://www.henishuo.com/wkwebview-js-h5-oc/" target="_blank" rel="external">实战</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/runloop/" itemprop="url">
                  RunLoop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T20:54:19+08:00" content="2016-May-Sunday">
              2016-May-Sunday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模型通常被称作<a href="http://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a> 。<br>或使用伪代码来展示下:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//程序一直运行状态</span></span><br><span class="line"> <span class="keyword">while</span> (AppIsRunning) &#123;</span><br><span class="line">      <span class="comment">//睡眠状态，等待唤醒事件</span></span><br><span class="line">      id whoWakesMe = SleepForWakingUp();</span><br><span class="line">      <span class="comment">//得到唤醒事件</span></span><br><span class="line">      id <span class="keyword">event</span> = GetEvent(whoWakesMe);</span><br><span class="line">      <span class="comment">//开始处理事件</span></span><br><span class="line">      HandleEvent(<span class="keyword">event</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现这种模型的关键点在于</strong>：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。<br>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。<br>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。<br>CFRunLoopRef 的代码是开源的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/</a>下载到整个 CoreFoundation 的源码来查看。<br>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="external">https://github.com/apple/swift-corelibs-foundation/</a>，这个版本的源码可能和现有 iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。)</p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>
<p>runloop 和线程的关系：<br>主线程的run loop默认是启动的。<br>iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。<br>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。<br>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p>
<pre><code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];
</code></pre><p>相对底层：<br>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p><strong>苹果不允许直接创建 RunLoop</strong>，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _<span class="built_in">CFRunLoopGet</span>(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _<span class="built_in">CFSetTSD</span>(..., thread, loop, __<span class="built_in">CFFinalizeRunLoop</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_self());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:<br>CFRunLoopRef</p>
<p>CFRunLoopModeRef</p>
<p><strong>CFRunLoopSourceRef</strong></p>
<p><strong>CFRunLoopTimerRef</strong></p>
<p><strong>CFRunLoopObserverRef</strong></p>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt=""><br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef (数据源) </strong>是事件产生的地方。Source有两个版本：Source0 和 Source1。<br>• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br>• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>
<p><strong>CFRunLoopTimerRef（定时源）</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef 是观察者</strong>，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span>        = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span>          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 Source/Timer/Observer 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDefaultRunLoopMode</span>（k<span class="built_in">CFRunLoopDefaultMode</span>）：默认，空闲状态</span><br><span class="line"><span class="built_in">UITrackingRunLoopMode</span>：ScrollView滑动时</span><br><span class="line"><span class="built_in">UIInitializationRunLoopMode</span>：启动时</span><br><span class="line"><span class="built_in">NSRunLoopCommonModes</span>（k<span class="built_in">CFRunLoopCommonModes</span>）：Mode集合</span><br></pre></td></tr></table></figure>
<p>苹果公开提供的 Mode 有两个：</p>
<pre><code>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）
NSRunLoopCommonModes（kCFRunLoopCommonModes）
</code></pre><p>这里有个概念叫 “CommonModes”（混合模式）：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>
<p>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</p>
<p>CFRunLoopRunInMode(CFStringRef modeName, …);</p>
<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRefrl</span>,<span class="built_in">CFRunLoopSourceRefsource</span>,<span class="built_in">CFStringRefmodeName</span>);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRefrl</span>,<span class="built_in">CFRunLoopObserverRefobserver</span>,<span class="built_in">CFStringRefmodeName</span>);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRefrl</span>,<span class="built_in">CFRunLoopTimerReftimer</span>,<span class="built_in">CFStringRefmode</span>);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRefrl</span>,<span class="built_in">CFRunLoopSourceRefsource</span>,<span class="built_in">CFStringRefmodeName</span>);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRefrl</span>,<span class="built_in">CFRunLoopObserverRefobserver</span>,<span class="built_in">CFStringRefmodeName</span>);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRefrl</span>,<span class="built_in">CFRunLoopTimerReftimer</span>,<span class="built_in">CFStringRefmode</span>);</span><br></pre></td></tr></table></figure>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">文档</a>里的说明，RunLoop 内部的逻辑大致如下:<br><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt=""></p>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。(代码省略)<br><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_3.png" alt=""><br>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>应用框架层即开发人员接触到的 Cocoa 等框架。<br>核心框架层包括各种核心框架、OpenGL 等内容。<br>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。</p>
<p>上面这个图把Mac OS X的架构分了四个部分：<br><img src="http://img.my.csdn.net/uploads/201303/03/1362298161_7637.jpg" alt=""></p>
<p>（1）User Experience，这个一般可以理解为Application.</p>
<p>（2）Application Frameworks，这个理解为主要包括像Cocoa这样的组件。</p>
<p>（3）Graphics and Media，这个理解为Application service和Core Service。</p>
<p>（4）Darwin，这个就是Mac OS X的kernel。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>通过 App 启动后 RunLoop 的状态可以看到，系统默认注册了5个Mode:（代码省略）</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。<br>4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。<br>5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>
<p>AutoreleasePool<br>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<p>系统级：GCD，mach kernel，block，pthread<br>应用层：NSTimer，UIEvent，Autorelease，NSObject(NSDelayedPerforming)，NSObject(NSThreadPerformAddition)，CADisplayLink，CATransition，CAAnimation，dispatch_get_main_queue()（GCD中dispatch到main queue的block会被dispatch到main RunLoop执行），NSPort，NSURLConnection，AFNetworking(这个第三方网络请求框架使用在开启新线程中添加自己的run loop监听事件)</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="external">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer是对RunLoopTimer的封装</p>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFN<span class="function"><span class="title">etwork</span>       -&gt;</span>ASIHttpRequest</span><br><span class="line">NSURLC<span class="function"><span class="title">onnection</span> -&gt;</span>AFNetworking</span><br><span class="line">NSURLS<span class="function"><span class="title">ession</span>    -&gt;</span>AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>
<ul>
<li><p>CFSocket 是最底层的接口，只负责 socket 通信。</p>
</li>
<li><p>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</p>
</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p><a href="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" target="_blank" rel="external"></a></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m 这" target="_blank" rel="external">AFURLConnectionOperation</a>个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<p>使用NSOperation+NSURLConnection并发模型都会面临NSURLConnection下载完成前线程退出导致NSOperation对象接收不到回调的问题。AFNetWorking解决这个问题的方法是按照官方的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/Reference/Reference.html#//apple_ref/occ/instm/NSURLConnection/initWithRequest:delegate:startImmediately:" target="_blank" rel="external">guid</a>上写的NSURLConnection的delegate方法需要在connection发起的线程runloop中调用，于是AFNetWorking直接借鉴了Apple自己的一个<a href="https://developer.apple.com/LIBRARY/IOS/samplecode/MVCNetworking/Introduction/Intro.html" target="_blank" rel="external">Demo</a>的实现方法单独起一个global thread，内置一个runloop，所有的connection都由这个runloop发起，回调也是它接收，不占用主线程，也不耗CPU资源。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<p>类似的可以用这个方法创建一个常驻服务的线程。</p>
<h3 id="TableView中实现平滑滚动延迟加载图片"><a href="#TableView中实现平滑滚动延迟加载图片" class="headerlink" title="TableView中实现平滑滚动延迟加载图片"></a>TableView中实现平滑滚动延迟加载图片</h3><p>利用CFRunLoopMode的特性，可以将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动UITrackingRunLoopMode这个mode时不会被加载而影响到。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *downloadedImage = ...;</span><br><span class="line">[<span class="keyword">self</span>.avatarImageView performSelector:<span class="keyword">@selector</span>(setImage:)</span><br><span class="line">     withObject:downloadedImage</span><br><span class="line">     afterDelay:<span class="number">0</span></span><br><span class="line">     inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br></pre></td></tr></table></figure>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m" target="_blank" rel="external">_ASAsyncTransactionGroup。</a></p>
<p><strong>参考：</strong></p>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="external">深入理解RunLoop</a>  <a href="https://github.com/ming1016/study/wiki/CFRunLoop" target="_blank" rel="external">CFRunLoop</a> <a href="http://blog.csdn.net/wzzvictory/article/details/9237973" target="_blank" rel="external">Objective-C之run loop详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/基础算法/" itemprop="url">
                  基础算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-19T11:01:00+08:00" content="2016-May-Thursday">
              2016-May-Thursday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="翻转二叉树（镜像）"><a href="#翻转二叉树（镜像）" class="headerlink" title="翻转二叉树（镜像）"></a>翻转二叉树（镜像）</h2><p>Invert a binary tree.</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>to</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>0.创建类 BinaryTreeNode<br>1.创建方法：传入根结点<br>2.判断根节点是否为空<br>3.判断左右结点是否同时为空<br>4.用self调用此方法，将根节点的左孩子，右孩子作为根节点传入<br>5.将左孩子右孩子的值交换<br>6.返回根节点</p>
<p>除去 LeetCode 自动生成的注释和方法定义，我所写的整个代码行数为 9 行，大概花了 5 分钟时间。代码如下所示：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode <span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode <span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            return <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.<span class="built_in">left</span> = invertTree(root.<span class="built_in">left</span>);</span><br><span class="line">        root.<span class="built_in">right</span> = invertTree(root.<span class="built_in">right</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode tmp = root.<span class="built_in">left</span>;</span><br><span class="line">        root.<span class="built_in">left</span> = root.<span class="built_in">right</span>;</span><br><span class="line">        root.<span class="built_in">right</span> = tmp;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这道题考查了什么呢？我觉得主要是考查了递归的思想。递归是程序设计的精髓，掌握了他可以将一个大问题分解成小问题，继而求解。比如对于此题来说，反转一个二叉树其实就是：<br>反转二叉树的左右子树<br>将左右子树交换<br>而第 1 步又是一个反转二叉树的问题，所以就可以用递归来处理了。然后再考虑好递归的结束条件，这道题就可以解决了。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> binarySearch2(<span class="built_in">int</span> arr[], <span class="built_in">int</span> <span class="keyword">value</span>, <span class="built_in">int</span> low, <span class="built_in">int</span> high) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        // 说明参数输入错误</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">target</span> = (low + high) * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == arr[<span class="keyword">target</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[<span class="keyword">target</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (binarySearch2(arr, <span class="keyword">value</span>, low , <span class="keyword">target</span> - <span class="number">1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (binarySearch2(arr, <span class="keyword">value</span>, <span class="keyword">target</span> + <span class="number">1</span>, high));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>OC版</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bubbleSort:(<span class="keyword">int</span> [])<span class="built_in">array</span> len:(<span class="keyword">size_t</span>)len &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = len - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[j];</span><br><span class="line">        <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">array</span>[j - <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试使用：</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">[<span class="keyword">self</span> bubbleSort:a len:<span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Swift版</strong></p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">var</span> arr: [Int])</span></span> -&gt;[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="comment">// 走多少趟</span></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">count</span> - <span class="number">1</span>; ++i &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后往前</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">var</span> j = arr.<span class="built_in">count</span> - <span class="number">1</span>; j &gt; i; --j &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 后者 &lt; 前者 ？ 交换 ： 不交换</span></span><br><span class="line">      <span class="keyword">if</span> arr[j] &lt; arr[j - <span class="number">1</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        </span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">        arr[j - <span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试使用：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于swift中数组也是结构体，是值类型，因此需要接收返回值才能得到排序后的数组</span></span><br><span class="line"><span class="selector-tag">var</span> arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">arr = bubbleSort(arr)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>OC</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)selectSort:(<span class="keyword">int</span> [])arr len:(<span class="keyword">int</span>)len &#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只需要n-1趟</span></span><br><span class="line">  <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">min</span> = i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第n+1趟起始找到末尾</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到比min位置更小的，就更新这一趟所找到的最小值的位置</span></span><br><span class="line">      <span class="built_in">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>]) &#123;</span><br><span class="line">        <span class="built_in">min</span> = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果min与i不相等，说明有比i位置更小的，所以需要交换</span></span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">min</span> != i) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = arr[<span class="built_in">min</span>];</span><br><span class="line">      arr[<span class="built_in">min</span>] = arr[i];</span><br><span class="line">      arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Swift版</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">var</span> arr: [Int])</span></span> -&gt;[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">min</span> = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只需要n-1趟</span></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">count</span> - <span class="number">1</span>; ++i &#123;</span><br><span class="line">    <span class="built_in">min</span> = i</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第n+1趟起始找到末尾</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">count</span>; ++j &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到比min位置更小的，就更新这一趟所找到的最小值的位置</span></span><br><span class="line">      <span class="keyword">if</span> arr[j] &lt; arr[<span class="built_in">min</span>] &#123;</span><br><span class="line">        <span class="built_in">min</span> = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果min与i不相等，说明有比i位置更小的，所以需要交换</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">min</span> != i &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">      arr[i] = arr[<span class="built_in">min</span>]</span><br><span class="line">      arr[<span class="built_in">min</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.henishuo.com/bubble-sort/" target="_blank" rel="external">冒泡</a> <a href="http://www.henishuo.com/select-sort/" target="_blank" rel="external">选择</a> <a href="http://visualgo.net" target="_blank" rel="external">动图</a> <a href="http://blog.devtang.com/2015/06/16/talk-about-tech-interview/" target="_blank" rel="external">二叉树</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/FMDB/" itemprop="url">
                  FMDB
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-19T10:29:21+08:00" content="2016-May-Thursday">
              2016-May-Thursday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>SQLite <a href="">(http://www.sqlite.org/docs.html)</a> 是一个轻量级的关系数据库。iOS SDK 很早就支持了 SQLite，在使用时，只需要加入 libsqlite3.dylib 依赖以及引入 sqlite3.h 头文件即可。但是，原生的 SQLite API 在使用上相当不友好，在使用时，非常不便。于是，开源社区中就出现了一系列将 SQLite API 进行封装的库，而 FMDB <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">(https://github.com/ccgus/fmdb) </a>则是开源社区中的优秀者。</p>
<p>FMDB 在使用上相当方便。以下是一个简单的例子：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSString</span>* docsdir = [<span class="symbol">NSSearchPathForDirectoriesInDomains</span>( <span class="symbol">NSDocumentDirectory</span>, <span class="symbol">NSUserDomainMask</span>, <span class="symbol">YES</span>) lastObject];</span><br><span class="line"><span class="symbol">NSString</span>* dbpath = [docsdir stringByAppendingPathComponent:@<span class="string">"user.sqlite"</span>]; </span><br><span class="line"><span class="symbol">FMDatabase</span>* db = [<span class="symbol">FMDatabase</span> databaseWithPath:dbpath];</span><br><span class="line">[db open];</span><br><span class="line"><span class="symbol">FMResultSet</span> *rs = [db executeQuery:@<span class="string">"select * from people"</span>];</span><br><span class="line">while ([rs next]) &#123;</span><br><span class="line">    <span class="symbol">NSLog</span>(@<span class="string">"%@ %@"</span>,</span><br><span class="line">        [rs stringForColumn:@<span class="string">"firstname"</span>], </span><br><span class="line">        [rs stringForColumn:@<span class="string">"lastname"</span>]);</span><br><span class="line">&#125;</span><br><span class="line">[db close];</span><br></pre></td></tr></table></figure>
<p>可以看到，使用 FMDB 后的数据库代码清晰明了，比原生的 API 优雅多了。另外，FMDB 同时兼容 ARC 和非 ARC 工程，会自动根据工程配置来调整相关的内存管理代码。</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><hr>
<p>该使用说明主要翻译自 fmdb 的 github 项目说明文档: <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">https://github.com/ccgus/fmdb</a></p>
<h3 id="引入相关文件"><a href="#引入相关文件" class="headerlink" title="引入相关文件"></a>引入相关文件</h3><p>首先将 FMDB 从 github 上 clone 下来，然后将以下文件 copy 到你的工程中：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FMDatabase<span class="selector-class">.h</span></span><br><span class="line">FMDatabase<span class="selector-class">.m</span></span><br><span class="line">FMDatabaseAdditions<span class="selector-class">.h</span></span><br><span class="line">FMDatabaseAdditions<span class="selector-class">.m</span></span><br><span class="line">FMDatabasePool<span class="selector-class">.h</span></span><br><span class="line">FMDatabasePool<span class="selector-class">.m</span></span><br><span class="line">FMDatabaseQueue<span class="selector-class">.h</span></span><br><span class="line">FMDatabaseQueue<span class="selector-class">.m</span></span><br><span class="line">FMResultSet<span class="selector-class">.h</span></span><br><span class="line">FMResultSet.m</span><br></pre></td></tr></table></figure>
<h3 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h3><p>建立数据库只需要如下一行即可 , 当该文件不存在时，fmdb 会自己创建一个。如果你传入的参数是空串：@”” ，则 fmdb 会在临时文件目录下创建这个数据库，如果你传入的参数是 NULL，则它会建立一个在内存中的数据库。</p>
<pre><code>FMDatabase *db = [FMDatabase databaseWithPath:@&quot;/tmp/tmp.db&quot;];
</code></pre><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>使用如下语句，如果打开失败，可能是权限不足或者资源不足。通常打开完操作操作后，需要调用 close 方法来关闭数据库。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="keyword">db</span> <span class="keyword">open</span>]) &#123;</span><br><span class="line">    <span class="comment">// error </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// some operation</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">db</span> <span class="keyword">close</span>];</span><br></pre></td></tr></table></figure>
<h3 id="执行更新操作"><a href="#执行更新操作" class="headerlink" title="执行更新操作"></a>执行更新操作</h3><p>除了 Select 操作之外，其它的都是更新操作。更新操作使用如下方法，如果有错误，可以用 error 参数中获得。</p>
<pre><code>-[FMDatabase executeUpdate:error:withArgumentsInArray:orVAList:]
</code></pre><h3 id="执行查询操作"><a href="#执行查询操作" class="headerlink" title="执行查询操作"></a>执行查询操作</h3><p>查询操作示例如下。注意：即使操作结果只有一行，也需要先调用 FMResultSet 的 next 方法。</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FMResultSet *<span class="keyword">s</span> = [db executeQuery:@<span class="string">"SELECT * FROM myTable"</span>]<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span> ([<span class="keyword">s</span> next]) &#123;</span><br><span class="line">    <span class="comment">//retrieve values for each record</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FMResultSet *<span class="keyword">s</span> = [db executeQuery:@<span class="string">"SELECT COUNT(*) FROM myTable"</span>]<span class="comment">;</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">s</span> next]) &#123;</span><br><span class="line">    int totalCount = [<span class="keyword">s</span> intForColumnIndex:<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FMDB 提供如下多个方法来获取不同类型的数据：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">intForColumn:</span></span><br><span class="line"><span class="symbol">longForColumn:</span></span><br><span class="line"><span class="symbol">longLongIntForColumn:</span></span><br><span class="line"><span class="symbol">boolForColumn:</span></span><br><span class="line"><span class="symbol">doubleForColumn:</span></span><br><span class="line"><span class="symbol">stringForColumn:</span></span><br><span class="line"><span class="symbol">dateForColumn:</span></span><br><span class="line"><span class="symbol">dataForColumn:</span></span><br><span class="line"><span class="symbol">dataNoCopyForColumn:</span></span><br><span class="line"><span class="symbol">UTF8StringForColumnIndex:</span></span><br><span class="line"><span class="symbol">objectForColumn:</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，你并不需要关闭 FMResultSet，因为相关的数据库关闭时，FMResultSet 也会被自动关闭。</p>
<h3 id="数据参数"><a href="#数据参数" class="headerlink" title="数据参数"></a>数据参数</h3><p>通常情况下，你可以按照标准的 SQL 语句，用 ? 表示执行语句的参数，如：</p>
<pre><code>INSERT INTO myTable VALUES (?, ?, ?)
</code></pre><p>然后，可以我们可以调用 executeUpdate 方法来将 ? 所指代的具体参数传入，通常是用变长参数来传递进去的，如下：</p>
<pre><code>NSString *sql = @&quot;insert into User (name, password) values (?, ?)&quot;;
[db executeUpdate:sql, user.name, user.password];
</code></pre><p>这里需要注意的是，参数必须是 NSObject 的子类，所以象 int,double,bool 这种基本类型，需要封装成对应的包装类才行，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，42 不能作为参数</span></span><br><span class="line">[db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, <span class="number">42</span>];</span><br><span class="line"><span class="comment">// 正确，将 42 封装成 NSNumber 类</span></span><br><span class="line">[db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">42</span>]];</span><br></pre></td></tr></table></figure>
<p>线程安全<br>如果我们的 app 需要多线程操作数据库，那么就需要使用 FMDatabaseQueue 来保证线程安全了。<br>切记不能在多个线程中共同一个 FMDatabase 对象并且在多个线程中同时使用，这个类本身不是线程安全的，这样使用会造成数据混乱等问题。<br>使用 FMDatabaseQueue 很简单，首先用一个数据库文件地址来初使化 FMDatabaseQueue，然后就可以将一个闭包 (block) 传入 inDatabase 方法中。<br>在闭包中操作数据库，而不直接参与 FMDatabase 的管理。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建，最好放在一个单例的类中</span></span><br><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue <span class="string">databaseQueueWithPath:</span>aPath];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">[queue <span class="string">inDatabase:</span>^(FMDatabase *db) &#123;</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">1</span>]];</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">2</span>]];</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">3</span>]];</span><br><span class="line"></span><br><span class="line">    FMResultSet *rs = [db <span class="string">executeQuery:</span>@<span class="string">"select * from foo"</span>];</span><br><span class="line">    <span class="keyword">while</span> ([rs next]) &#123;</span><br><span class="line">        <span class="comment">// …</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要支持事务</span></span><br><span class="line">[queue <span class="string">inTransaction:</span>^(FMDatabase *db, BOOL *rollback) &#123;</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">1</span>]];</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">2</span>]];</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">3</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (whoopsSomethingWrongHappened) &#123;</span><br><span class="line">        *rollback = YES;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// etc…</span></span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO myTable VALUES (?)"</span>, [NSNumber <span class="string">numberWithInt:</span><span class="number">4</span>]];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><hr>
<p>为了查看 Sqlite 中的数据，一个好的图形化界面的数据库管理程序是必不可少的。mysql 有 phpMyAdmin，那么 sqlite 呢？<br>我主要使用的是 Firefox 的一个名为 SQLite Manager 的插件，安装此插件后，可以直接打开后缀名为 sqlite 的数据库文件。SQLite Manager 提供一个图形化的界面来执行数据查询或更改操作。如下图所示：</p>
<p><img src="http://blog.devtang.com/images/sqlite_manager.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>FMDB 将 SQLite API 进行了很友好的封装，使用上非常方便，对于那些使用纯 Sqlite API 来进行数据库操作的 app，可以考虑将其迁移到基于 FMDB 上，这对于以后数据库相关功能的开发维护，可以提高不少效率。</p>
<p>参考：<a href="http://blog.devtang.com/2012/04/22/use-fmdb/" target="_blank" rel="external">在iOS开发中使用FMDB</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/UIWebView与JS的交互/" itemprop="url">
                  UIWebView与JS的交互
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T22:52:03+08:00" content="2016-May-Wednesday">
              2016-May-Wednesday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要实现这样一个需求：<strong>按照本地的CSS文件展示一串网络获取的带HTML格式的只有body部分的文本，需要自己拼写完整的HTML。除此之外，还需要禁用获取的HTML文本中自带的 &lt; img &gt; 标签自动加载，并把下载图片的操作放在native端来处理，并通过JS将图片在Cache中的地址返回给UIWebview</strong>。</p>
<p>之所以要把图片操作放在native端做的好处在于：1、可以进行本地缓存，下次进入这篇文章可以直接从缓存读取，提高响应速度并且节省用户流量。2、可以实现点击图片放大、保存图片到相册等操作。</p>
<p>技术难点也有两个：1、如何让HTML文本onLoad的时候，禁用自身的图片加载而是从本地获取图片？2、如何把native端下载好的图片返回给网页？</p>
<p>翻看文档可只找到了一个 <code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script</code>和JS简易交互的方法，无法实现。</p>
<p>Github上的<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a> 这个用于UIWebView/WebViews和JS交互的封装库。</p>
<p>看sample的时候我容易被各种回调搞晕，我们先看代码。</p>
<p>一开始，我们在Native端和JS端都分别进行初始化：</p>
<h4 id="OC端："><a href="#OC端：" class="headerlink" title="OC端："></a>OC端：</h4><pre><code>@property WebViewJavascriptBridge* bridge;
</code></pre><p>对应的初始化代码如下，在初始化中直接包含了一个用于接收JS的回调：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">_bridge</span> = [<span class="type">WebViewJavascriptBridge</span> bridgeForWebView:webView webViewDelegate:self handler:^(id <span class="class"><span class="keyword">data</span>, <span class="type">WVJBResponseCallback</span> responseCallback) &#123;  </span><br><span class="line">        <span class="type">NSLog</span>(@"<span class="type">ObjC</span> <span class="title">received</span> <span class="title">message</span> <span class="title">from</span> <span class="type">JS</span>: %@", <span class="title">data</span>);</span><br><span class="line">        <span class="title">responseCallback</span>(@"<span class="type">Response</span> <span class="title">for</span> <span class="title">message</span> <span class="title">from</span> <span class="type">ObjC</span>");</span><br><span class="line">&#125;];</span></span><br></pre></td></tr></table></figure>
<h4 id="JS端："><a href="#JS端：" class="headerlink" title="JS端："></a>JS端：</h4><p>(以下是固定写法，你自己的JS文件中必须包含如下代码)</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectWebViewJavascriptBridge</span><span class="params">(callback)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">        <span class="keyword">callback</span>(WebViewJavascriptBridge)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        document.addEventListener(<span class="string">'WebViewJavascriptBridgeReady'</span>,   <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">callback</span>(WebViewJavascriptBridge)</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span><span class="params">(bridge)</span> </span>&#123;  </span><br><span class="line">    bridge.init(<span class="function"><span class="keyword">function</span><span class="params">(message, responseCallback)</span> </span>&#123;</span><br><span class="line">        log(<span class="string">'JS got a message'</span>, message)</span><br><span class="line">        <span class="keyword">var</span> data = &#123; <span class="string">'Javascript Responds'</span>:<span class="string">'Wee!'</span> &#125;</span><br><span class="line">        log(<span class="string">'JS responding with'</span>, data)</span><br><span class="line">        responseCallback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们要知道，在<code>WebViewJavascriptBridge</code>中，交互的方式只有两种：<code>send</code> 和 <code>callHandle</code>，JS和OC都有这两个方法，所以对应的四种关系是：<br><img src="http://kittenyang.com/content/images/2015/Aug/Screen-Shot-2015-08-02-at-01-35-51.png" alt=""></p>
<p>以上表中的对应关系的解读是，例如第一条：在JS中如果调用了<code>bridge.send()</code>，那么将触发OC端<strong>_bridge初始化方法中的回调</strong>。</p>
<p>同理，第二条，在JS中调用了<code>bridge.callHandler(&#39;testJavascriptHandler&#39;)</code>，它将触发OC端注册的同名方法:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bridge.registerHandler(<span class="string">'testJavascriptHandler'</span>, function(<span class="built_in">data</span>, responseCallback) &#123;  </span><br><span class="line">        <span class="keyword">log</span>(<span class="string">'ObjC called testJavascriptHandler with'</span>, <span class="built_in">data</span>)</span><br><span class="line">        <span class="built_in">var</span> responseData = &#123; <span class="string">'Javascript Says'</span>:<span class="string">'Right back atcha!'</span> &#125;</span><br><span class="line">        <span class="keyword">log</span>(<span class="string">'JS responding with'</span>, responseData)</span><br><span class="line">        responseCallback(responseData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>了解了使用规则，下面来看看在我们这个实际需求中应用的整体思路：</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/-----2015-08-07---3-14-34.png" alt=""></p>
<h3 id="–-1-–"><a href="#–-1-–" class="headerlink" title="– 1 –"></a>– 1 –</h3><p>首先，我们要做的第一步是替换获取的HTML文本中默认的<code>src</code>，以避免其会自动加载图片。</p>
<pre><code>NSString *_content = [contentstring stringByReplacingOccurrencesOfString:@&quot;src&quot; withString:@&quot;esrc&quot;];
</code></pre><h3 id="–-2-–"><a href="#–-2-–" class="headerlink" title="– 2 –"></a>– 2 –</h3><p>因为我们获取的只是HTML的body部分，因此我们需要自己书写完整的HTML。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"image.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"zepto.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"onLoaded()"</span>&gt;</span>  </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们让<code>&lt;body onload=&quot;onLoaded()&quot;&gt;</code>的时候去调用JS中的 <code>onLoaded()</code>函数。在这个函数中我们遍历所有img标签的 <code>esrc</code>，保存为一个数组返回给 OC 端，让native端去下载这些图片。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onLoaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> allImage = <span class="built_in">document</span>.querySelectorAll(<span class="string">"img"</span>);</span><br><span class="line">        allImage = <span class="built_in">Array</span>.prototype.slice.call(allImage, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">var</span> imageUrlsArray = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        allImage.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> esrc = image.getAttribute(<span class="string">"esrc"</span>);</span><br><span class="line">            <span class="keyword">var</span> newLength = imageUrlsArray.push(esrc);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        bridge.send(imageUrlsArray);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="–-3-–"><a href="#–-3-–" class="headerlink" title="– 3 –"></a>– 3 –</h3><p><code>bridge.send</code>会触发WebViewJavascriptBridge初始化方法 <code>+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler;</code>中的handler，我们在handler的block中下载所有图片。并且把下载完的图片在cache中的地址返回个JS。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark -- 下载全部图片</span></span><br><span class="line">-(<span class="keyword">void</span>)downloadAllImagesInNative:(<span class="built_in">NSArray</span> *)imageUrls&#123;</span><br><span class="line"></span><br><span class="line">    SDWebImageManager *manager = [SDWebImageManager sharedManager];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化一个置空元素数组</span></span><br><span class="line">    _allImagesOfThisArticle = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:imageUrls.count];<span class="comment">//本地的一个用于保存所有图片的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; imageUrls.count<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        [_allImagesOfThisArticle addObject:[<span class="built_in">NSNull</span> null]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; imageUrls.count<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *_url = imageUrls[i];</span><br><span class="line"></span><br><span class="line">        [manager downloadImageWithURL:[<span class="built_in">NSURL</span> URLWithString:_url] options:SDWebImageHighPriority progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">NSString</span> *imgB64 = [<span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>) base64EncodedStringWithOptions:<span class="built_in">NSDataBase64Encoding64CharacterLineLength</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把图片在磁盘中的地址传回给JS</span></span><br><span class="line">                    <span class="built_in">NSString</span> *key = [manager cacheKeyForURL:imageURL];</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">NSString</span> *source = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"data:image/png;base64,%@"</span>, imgB64];</span><br><span class="line">                    [_bridge callHandler:<span class="string">@"imagesDownloadComplete"</span> data:@[key,source]];</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="–-4-–"><a href="#–-4-–" class="headerlink" title="– 4 –"></a>– 4 –</h3><p><code>[_bridge callHandler:@&quot;imagesDownloadComplete&quot; data:@[key,source]]</code>会触发JS中的 <code>function imagesDownloadComplete()</code>。在这个函数中遍历所有img标签，把传过来的图片地址赋值给img的src。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">![]<span class="function"><span class="keyword">function</span> <span class="title">imagesDownloadComplete</span>(<span class="params">pOldUrl, pNewUrl</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> allImage = <span class="built_in">document</span>.querySelectorAll(<span class="string">"img"</span>);</span><br><span class="line">    allImage = <span class="built_in">Array</span>.prototype.slice.call(allImage, <span class="number">0</span>);</span><br><span class="line">    allImage.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (image.getAttribute(<span class="string">"esrc"</span>) == pOldUrl || image.getAttribute(<span class="string">"esrc"</span>) == <span class="built_in">decodeURIComponent</span>(pOldUrl)) &#123;</span><br><span class="line">            image.src = pNewUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>至此，通过<code>WebViewJavascriptBridge</code>处理UIWebView和JS交互实现本地处理网页图片的下载操作就基本完成了。这个例子展现了一个完整的过程，基本涉及了JS和OC的各种交互包括OC调用JS、JS调用OC等。如果你有其它的业务需求，也基本按照这个流程就可以依样画葫芦了，唯一不同的也就是业务逻辑了。</p>
<p>下面我再举一个例子。也是出现在我的业务需求里的，就是<strong>点击网页上的图片，图片会以Zoom-out的动画放大，左右滑动可以查看其它图片，同时还需要双击放大查看、保存图片等功能</strong>。 类似这样:</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/objs.gif" alt=""></p>
<p>乍一看，我们点击的是一张网页上的图片，怎么可能让这张图片单独跳出来？而且还能左右滑动显示其它图片？</p>
<p>首先我们还是需要去改造网络获取的那段HTML文本，正则匹配出<code>&lt;img esrc=http://....</code>,加上<code>onClick</code>事件，绑定一个JS的方法，并把这个esrc作为参数传入这个绑定的方法中。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正则替换</span></span><br><span class="line">NSRegularExpression *regex = [NSRegularExpression <span class="string">regularExpressionWithPattern:</span>@<span class="string">"(&lt;img[^&gt;]+esrc=\")(\\S+)\""</span> <span class="string">options:</span><span class="number">0</span> <span class="string">error:</span>nil];  </span><br><span class="line">result = [regex <span class="string">stringByReplacingMatchesInString:</span>newContent <span class="string">options:</span><span class="number">0</span> <span class="string">range:</span>NSMakeRange(<span class="number">0</span>, newContent.length) <span class="string">withTemplate:</span>@<span class="string">"&lt;img esrc=\"$2\" onClick=\"javascript:onImageClick('$2')\""</span>];</span><br></pre></td></tr></table></figure>
<p>JS中<code>onImageClick()</code>函数。这个函数的主要任务是：<strong>获取点击图片的在所有图片中的编号以及在当前屏幕中的位置。并把这些信息返回给OC</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onImageClick</span>(<span class="params">picUrl</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> allImage = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p img[esrc]"</span>);</span><br><span class="line">        allImage = <span class="built_in">Array</span>.prototype.slice.call(allImage, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">var</span> urls = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> height = <span class="number">0</span>;</span><br><span class="line">        allImage.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> imgUrl = image.getAttribute(<span class="string">"esrc"</span>);</span><br><span class="line">            <span class="keyword">var</span> newLength = urls.push(imgUrl);</span><br><span class="line">            <span class="keyword">if</span>(imgUrl == picUrl || imgUrl == <span class="built_in">decodeURIComponent</span>(picUrl))&#123;</span><br><span class="line">                index = newLength<span class="number">-1</span>;</span><br><span class="line">                x = image.getBoundingClientRect().left;</span><br><span class="line">                y = image.getBoundingClientRect().top;</span><br><span class="line">                x = x + <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">                y = y + <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">                width = image.width;</span><br><span class="line">                height = image.height;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"x:"</span>+x +<span class="string">";y:"</span> + y+<span class="string">";width:"</span>+image.width +<span class="string">";height:"</span>+image.height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"检测到点击"</span>);</span><br><span class="line"></span><br><span class="line">        bridge.callHandler(<span class="string">'imageDidClicked'</span>, &#123;<span class="string">'index'</span>:index,<span class="string">'x'</span>:x,<span class="string">'y'</span>:y,<span class="string">'width'</span>:width,<span class="string">'height'</span>:height&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"JS已经发出imgurl和index，同时收到回调，说明OC已经收到数据"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bridge.callHandler</code> 会触发OC中的 <code>[_bridge registerHandler:@&quot;imageDidClicked&quot; handler:^(id data, WVJBResponseCallback responseCallback){}]</code>。我们可以再handler中获得JS传过来的点击图片在所有图片中的编号，以及点击图片在当前图片中的空间位置。要实现点击图片Zoom-out的效果，我们要善于「作弊」。网页中的图片固然不能「跳」出来放大，但我们可以根据JS传回来的x、y、width、height这些位置信息自己创建一个UIImageView,image和当前点击图片一致，设置透明度为0，add到UIWebView上面。并通过<a href="https://github.com/ideaismobile/IDMPhotoBrowser" target="_blank" rel="external">IDMPhotoBrowser</a> 这个开源库实现图片浏览。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[_bridge registerHandler:@<span class="string">"imageDidClicked"</span> handler:^(<span class="name">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line"></span><br><span class="line">    NSInteger index = [[data objectForKey:@<span class="string">"index"</span>] integerValue]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    CGFloat originX = [[data objectForKey:@<span class="string">"x"</span>] floatValue]<span class="comment">;</span></span><br><span class="line">    CGFloat originY = [[data objectForKey:@<span class="string">"y"</span>] floatValue]<span class="comment">;</span></span><br><span class="line">    CGFloat width   = [[data objectForKey:@<span class="string">"width"</span>] floatValue]<span class="comment">;</span></span><br><span class="line">    CGFloat height  = [[data objectForKey:@<span class="string">"height"</span>] floatValue]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    tappedImageView.alpha = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    tappedImageView.frame = CGRectMake(<span class="name">originX</span>, originY, width, height)<span class="comment">;</span></span><br><span class="line">    tappedImageView.image = _allImagesOfThisArticle[index]<span class="comment">;//_allImagesOfThisArticle是一个本地数组用来存放所有图片</span></span><br><span class="line"></span><br><span class="line">    NSLog(@<span class="string">"OC已经收到JS的imageDidClicked了: %@"</span>, data)<span class="comment">;</span></span><br><span class="line">    responseCallback(@<span class="string">"OC已经收到JS的imageDidClicked了"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    //点击放大图片</span><br><span class="line">    [self presentPhotosBrowserWithInitialPage:index animatedFromView:tappedImageView]<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>由于我用的是<a href="http://www.sublimetext.com/3" target="_blank" rel="external">Sublime Text</a>,所以无法进行JS的调试。如果要用<a href="https://github.com/atom" target="_blank" rel="external">Atom</a>调试，又感觉有点小题大做。我就是想要有个地方可以轻松地看到是否打印出了<code>console.log</code>或者JS函数是否被调用了。始终相信，任何问题都是可以解决的。我们可以用Safari。</p>
<p>连上你的iPhone或者使用模拟器，当你的程序当前显示了一个UIWebView，Safari会自动识别这个UIWebview，并可以在<code>开发</code>菜单栏中找到你的设备进行调试。</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/-----2015-08-07---4-33-58.png" alt=""></p>
<p>选择<code>控制台</code>,你就可以看到久违的调试窗口以及JS的<code>console.log</code>了。</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/-----2015-08-07---4-36-30.png" alt=""></p>
<p>以上就是使用 <code>WebViewJavascriptBridge</code> 进行UIWebView与JS的深度交互的例子。</p>
<p>Node.JS都可以写服务器了，React Native都可以开发iOS了。学无止境，iOS应该先搞定OC和Swift再去搞前端。</p>
<p>参考：<a href="http://kittenyang.com/webview-javascript-bridge/" target="_blank" rel="external">UIWebView与JS的深度交互</a>         </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/iOS 优化界面流畅的技巧/" itemprop="url">
                  iOS 优化界面流畅的技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T21:42:46+08:00" content="2016-May-Wednesday">
              2016-May-Wednesday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>date: 2015-05-18 21:42:46</p>
<h2 id="CPU-资源消耗原因和解决方案"><a href="#CPU-资源消耗原因和解决方案" class="headerlink" title="CPU 资源消耗原因和解决方案"></a>CPU 资源消耗原因和解决方案</h2><font color="#8FD228" size="3"> 对象创建 </font>


<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>
<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>
<font color="#8FD228" size="3"> 对象调整 </font>

<p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>
<font color="#8FD228" size="3"> 对象销毁 </font>


<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [tmp <span class="class"><span class="keyword">class</span>];</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
 <font color="#8FD228" size="3">  布局计算 </font>


<p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>
<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>
<font color="#8FD228" size="3"> Autolayout </font>


<p>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/" target="_blank" rel="external">http://pilky.me/36/</a>。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
<font color="#8FD228" size="3"> 文本计算 </font>


<p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：<br>用 </p>
<pre><code>[NSAttributedString boundingRectWithSize:options:context:] 
</code></pre><p>来计算文本宽高，用 </p>
<pre><code>-[NSAttributedString drawWithRect:options:context:] 
</code></pre><p>来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。<br>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<font color="#8FD228" size="3"> 文本渲染 </font>


<p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<font color="#8FD228" size="3"> 图片的解码 </font>


<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<font color="#8FD228" size="3"> 图像的绘制 </font>


<p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#8FD228" size="3">  GPU 资源消耗原因和解决方案 </font>


<p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>
<font color="#8FD228" size="3"> 纹理的渲染 </font>

<p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：<a href="iosres.com">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p>
<font color="#8FD228" size="3">  视图的混合(Composing) </font>

<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<font color="#8FD228" size="3"> 图形的生成 </font>

<p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<h2 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h2><h4 id="预排版"><a href="#预排版" class="headerlink" title="预排版"></a>预排版</h4><p>当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。</p>
<p>对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/" target="_blank" rel="external">FDTemplateLayoutCell</a>。</p>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。</p>
<p>对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。</p>
<h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><p>我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：<a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="external">YYAsyncLayer</a>。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。</p>
<p>当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。</p>
<p>目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。</p>
<h4 id="全局并发控制"><a href="#全局并发控制" class="headerlink" title="全局并发控制"></a>全局并发控制</h4><p>当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：</p>
<p>ios_dispatch_blocked_1 ios_dispatch_blocked_2</p>
<p>大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：SocialAppLayout，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。</p>
<p>使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 <a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="external">YYDispatchQueuePool</a>，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。</p>
<h4 id="更高效的异步图片加载"><a href="#更高效的异步图片加载" class="headerlink" title="更高效的异步图片加载"></a>更高效的异步图片加载</h4><p>SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。(- -太吊了)在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。</p>
<h4 id="其他可以改进的地方"><a href="#其他可以改进的地方" class="headerlink" title="其他可以改进的地方"></a>其他可以改进的地方</h4><p>上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：</p>
<p>列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。</p>
<p>再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。</p>
<p>目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。</p>
<p>把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。</p>
<h3 id="如何评测界面的流畅度"><a href="#如何评测界面的流畅度" class="headerlink" title="如何评测界面的流畅度"></a>如何评测界面的流畅度</h3><p>最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&gt; Profile -&gt; 修改代码这样一个流程，优先解决最值得优化的地方。</p>
<p>如果你需要一个明确的 FPS 指示器，可以尝试一下 <a href="https://github.com/kconner/KMCGeigerCounter" target="_blank" rel="external">KMCGeigerCounter</a>。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1x1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。</p>
<p>我自己也写了个简单的 FPS 指示器：<a href="https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m" target="_blank" rel="external">FPSLabel</a> 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。</p>
<p>最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。</p>
<p>参考：<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/UIView和CALayer/" itemprop="url">
                  UIView和CALayer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T18:07:01+08:00" content="2016-May-Wednesday">
              2016-May-Wednesday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>UIView和CALayer都继承自NSObjet。</li>
</ul>
<h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><ul>
<li>UIView的继承结构为: UIResponder : NSObject。<ul>
<li>UIResponder是用来响应事件的，也就是UIView可以响应用户事件</li>
</ul>
</li>
<li>CALayer的继承结构为： NSObject<ul>
<li>直接从 NSObject继承，因为缺少了UIResponder类，所以CALayer悲催的不能响应任何用户事件。  </li>
</ul>
</li>
<li>UIView是视图的基类，UIViewController是视图控制器的基类，UIResponder是表示一个可以在屏幕上响应触摸事件的对象；</li>
</ul>
<p><img src="http://www.henishuo.com/wp-content/uploads/2015/12/lv.png" alt=""></p>
<h4 id="所属框架"><a href="#所属框架" class="headerlink" title="所属框架"></a>所属框架</h4><ul>
<li>UIView是在 /System/Library/Frameworks/UIKit.framework中定义的<ul>
<li>UIKit主要是用来构建用户界面，并且是可以响应事件的（源于UIView的父类UIResponder）</li>
<li>UIView是用来显示内容的，可以处理用户事件</li>
</ul>
</li>
<li>CALayer是在/System/Library/Frameworks/QuartzCore.framework定义的。<ul>
<li>CALayer作为一个低级的，可以承载绘制内容的底层对象出现在该框架中。</li>
<li>CALayer是用来绘制内容的，对内容进行动画处理依赖与UIView来进行显示，不能处理用户事件。</li>
</ul>
</li>
</ul>
<h4 id="作用机制"><a href="#作用机制" class="headerlink" title="作用机制"></a>作用机制</h4><ul>
<li><p>当UIView需要显示的时候，会调用drawRect：方法进行绘图，并且会将所有内容绘制在自己的图层上（CALayer上），系统将图层拷贝到屏幕上，完成UIView的显示。</p>
<ul>
<li>通过操作这个CALayer对象，可以很方便的调整UIView的一些界面属性，比如：阴影，圆角大小，旋转等等。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewT.layer.cornerRadius = <span class="number">10</span>;<span class="comment">//设置半径</span></span><br><span class="line">viewT.layer.borderWidth = <span class="number">10</span>;<span class="comment">//设置边框的宽度，当然可以不要</span></span><br><span class="line">viewT.layer.borderColor = [[<span class="built_in">UIColor</span> redColor] <span class="built_in">CGColor</span>];<span class="comment">//设置边框的颜色</span></span><br><span class="line">viewT.layer.masksToBounds = <span class="literal">YES</span>;<span class="comment">//设为NO去试试</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>所以UIView相比CALayer最大区别是UIView可以响应用户事件，而CALayer不可以。UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。</strong></p>
</li>
<li><p><strong>UIView和CALayer是相互依赖的关系。UIView依赖与CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力。</strong></p>
</li>
<li><strong>UIView来自CALayer，高于CALayer，是CALayer的高层实现与封装。UIView的所有特性来源于CALayer支持。</strong><br>参考：<br><a href="http://www.henishuo.com/core-animation/" target="_blank" rel="external">图片引用</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/14/单元测试/" itemprop="url">
                  单元测试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-14T23:50:28+08:00" content="2016-May-Saturday">
              2016-May-Saturday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在计算机编程中，<strong>单元测试</strong>（英语：Unit Testing）又称为<strong>模块测试</strong>, 是针对程序模块的最小单位来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 – 维基百科</p>
<p>使用单元测试以后，我们就没必要为了测试某个小模块去编译我们的程序，然后去等待模拟器启动然后到你需要验证的模块去。如果项目很大，编译要等很长时间</p>
<p>####单元测试能节约我们的时间，提高开发效率，对于项目越大的效果越明显。</p>
<p>###XCTest<br>XCode4.x时代Xcode集成的是<strong>OCUnit</strong>，到了XCode5.x时代就升级为了<strong>XCTest</strong>,并且到了XCode7时代还有了进行UI测试的能力。除了官方自带的，还有一些比较出名的第三方的测试框架，如：GHUnit,KiWi，OCMock,Specta等,当然本文不讨论这些第三方框架。怎么知道我们的项目有没有加上单元测试，用Xcode打开你的项目，看文件导航栏有没有类似下图的两个文件夹（TestDemo是工程名）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-3e92ba680ba3a3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mou icon"></p>
<p>其实在我们新建工程的时候就可以为我们的工程选择是否带上单元测试，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-6ea5e9824aac3772.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果你的项目没有上面说的两个文件，你可以通过新建一个Target的方式添加，如下图：<br>就是给项目添加测试TARGETS</p>
<p>方法1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-640964197cbf1fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>方法2<br><img src="http://upload-images.jianshu.io/upload_images/465386-4ea67ede8f12800f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这2个文件夹目录下分别都有2个文件，一个.m文件和一个plist文件。并且.m文件有4个方法，如下：</p>
<p>测试文件名称自定义，可以删除自己创建，注意要继承自XCTestCase<br>通过Xcode的File-&gt;New-&gt;File-&gt;Source选择Unit Test Case Class来新建一个UserTests,注意要继承XCTestCase类。</p>
<p>项目名+Test的.m文件里面默认有4个方法，这个文件里面主要做一些逻辑的测试。项目名+UITest的.m文件里默认有3个方法。这个文件里面主要做一些UI的测试。</p>
<p>在讲解如何写测试方法前，先说说默认的方法的作用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  MZToolsTest.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MZToolsTest</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MZToolsTest</span></span></span><br><span class="line"><span class="comment">//每个test方法执行前调用，在这个测试用例里进行一些通用的初始化工作</span></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">   [<span class="keyword">super</span> setUp];</span><br><span class="line">   <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个test方法执行后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">   <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">   [<span class="keyword">super</span> tearDown];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试方法样例</span></span><br><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line">   <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">   <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法主要是做性能测试的，所谓性能测试，主要就是评估一段代码的运行时间。该方法就是性能测试方法的样例。</span></span><br><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">   <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">   [<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">       <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>测试用例方法非常简单，从testExample这个方法我们大概知道怎么写了，方法名只需要以test开头，是的，就是这么简单。<br>现在我们模拟登录这个功能来写一个登录模块的测试用例</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface User : NSObject

@property (nonatomic, copy) NSString *userName;
@property (nonatomic, copy) NSString *passWord;

/**
 *  判断字符串中是否有中文
 */
- (BOOL)isChinese:(NSString *)string;

@end
</code></pre><p>现在我们通过Xcode的File-&gt;New-&gt;File-&gt;Source选择Unit Test Case Class来新建一个UserTests,注意要继承XCTestCase类。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-46c15939c20c31fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来我们为User类写一个测试isChinese方法的测试方法，叫做testIsChinese,测试用例具体如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-aeb21b3114c57784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这样，你只要点击测试方法旁边的那个菱形的按钮就可以运行该测试方法！通过测试会变成绿色的对勾，失败会变成红色的叉叉。到这里测试用例你就会写了。也许你会在意那些断言，这样的断言有18个，如下</p>
<pre><code>XCTFail(format…)  //生成一个失败的测试；
XCTAssertNil(a1, format...)  //为空判断，a1为空时通过，反之不通过；
XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；
XCTAssert(expression, format...) //当expression求值为TRUE时通过；
XCTAssertTrue(expression, format...) //当expression求值为TRUE时通过；
XCTAssertFalse(expression, format...)  //当expression求值为False时通过；
XCTAssertEqualObjects(a1, a2, format...)  //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；
XCTAssertNotEqualObjects(a1, a2, format...)  //判断不等，[a1 isEqual:a2]值为False时通过；
XCTAssertEqual(a1, a2, format...)  //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；
XCTAssertNotEqual(a1, a2, format...)  //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；

XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)  //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；

XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...)   //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；

XCTAssertThrows(expression, format...)  //异常测试，当expression发生异常时通过；反之不通过；

XCTAssertThrowsSpecific(expression, specificException, format...)  //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；

XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；

XCTAssertNoThrow(expression, format…)  //异常测试，当expression没有发生异常时通过测试；

XCTAssertNoThrowSpecific(expression, specificException, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；

XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过
</code></pre><p>UI测试稍后更新…..</p>
<p>###总结<br>这只是苹果官方集成在Xcode中的简单框架，优点就是简单，缺点也是简单。当然它的用法也绝非如此，有很多还待开发。苹果官方也有一个Demo，地址点击这里</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/hello-hexo/" itemprop="url">
                  Hello Hexo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:43:54+08:00" content="2016-May-Wednesday">
              2016-May-Wednesday
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="图片方案"><a href="#图片方案" class="headerlink" title="图片方案"></a>图片方案</h3><p>hexo 下插入图片现在大概有几个方案</p>
<p>1.1 放在根目录</p>
<p>早期大部分的方案是把图片放在 source/img 下，然后在 markdown 里写 <code>![img](/source/img/img.png)</code>。显然这样在本地的编辑器里完全不能正确识别图片的位置。</p>
<p>1.2 asset-image</p>
<p>在 hexo 2.x 时出现的插件，后来被吸纳进 <code>hexo 3 core</code> ，用法的介绍见 <a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="external">资源文件夹 | Hexo</a> 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。</p>
<p>2 解决方案</p>
<pre><code>[CodeFalling/hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)
</code></pre><p>2.1 使用</p>
<p>首先确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。</p>
<p>在 hexo 目录，执行</p>
<pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save
</code></pre><p>假设在</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MacGesture2-Publish</span><br><span class="line">├── apppicker<span class="selector-class">.jpg</span></span><br><span class="line">├── logo<span class="selector-class">.jpg</span></span><br><span class="line">└── rules.jpg</span><br></pre></td></tr></table></figure>
<p>MacGesture2-Publish.md<br>这样的目录结构（目录名和文章名一致），只要使用 <img src="MacGesture2-Publish/logo.jpg" alt="logo"> 就可以插入图片。</p>
<p>生成的结构为</p>
<p>public/2015/10/18/MacGesture2-Publish<br>├── apppicker.jpg<br>├── index.html<br>├── logo.jpg<br>└── rules.jpg<br>同时，生成的 html 是</p>
<pre><code>&lt;img src=&quot;/2015/10/18/MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt;
</code></pre><p>而不是愚蠢的</p>
<pre><code>&lt;img src=&quot;MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt;
</code></pre><p>值得一提的是，这个插件对于 <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">CodeFalling/hexo-renderer-org</a> 同样有效。</p>
<p>参考：<a href="http://www.tuicool.com/articles/umEBVfI" target="_blank" rel="external">在 hexo 中无痛使用本地图片</a> <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">MK语法</a><br><a href="http://baixin.io/2016/03/01/iOSNote/" target="_blank" rel="external">iOS Develop</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhumuzhi" />
          <p class="site-author-name" itemprop="name">zhumuzhi</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhumuzhi</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
