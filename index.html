<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="朱慕之的Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="朱慕之的Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朱慕之的Blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 朱慕之的Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">朱慕之的Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-首页"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-归档"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-标签"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/UIWebView与JS的交互/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T22:52:03+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="title-UIWebView与JS的交互"><a href="#title-UIWebView与JS的交互" class="headerlink" title="title:UIWebView与JS的交互"></a>title:UIWebView与JS的交互</h2><p>date: 2016-05-18 22:52:03</p>
<p>要实现这样一个需求：<strong>按照本地的CSS文件展示一串网络获取的带HTML格式的只有body部分的文本，需要自己拼写完整的HTML。除此之外，还需要禁用获取的HTML文本中自带的 &lt; img &gt; 标签自动加载，并把下载图片的操作放在native端来处理，并通过JS将图片在Cache中的地址返回给UIWebview</strong>。</p>
<p>之所以要把图片操作放在native端做的好处在于：1、可以进行本地缓存，下次进入这篇文章可以直接从缓存读取，提高响应速度并且节省用户流量。2、可以实现点击图片放大、保存图片到相册等操作。</p>
<p>技术难点也有两个：1、如何让HTML文本onLoad的时候，禁用自身的图片加载而是从本地获取图片？2、如何把native端下载好的图片返回给网页？</p>
<p>翻看文档可只找到了一个 <code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script</code>和JS简易交互的方法，无法实现。</p>
<p>Github上的<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a> 这个用于UIWebView/WebViews和JS交互的封装库。</p>
<p>看sample的时候我容易被各种回调搞晕，我们先看代码。</p>
<p>一开始，我们在Native端和JS端都分别进行初始化：</p>
<h4 id="OC端："><a href="#OC端：" class="headerlink" title="OC端："></a>OC端：</h4><pre><code>@property WebViewJavascriptBridge* bridge;
</code></pre><p>对应的初始化代码如下，在初始化中直接包含了一个用于接收JS的回调：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">_bridge</span> = [<span class="type">WebViewJavascriptBridge</span> bridgeForWebView:webView webViewDelegate:self handler:^(id <span class="class"><span class="keyword">data</span>, <span class="type">WVJBResponseCallback</span> responseCallback) &#123;  </span><br><span class="line">        <span class="type">NSLog</span>(@"<span class="type">ObjC</span> <span class="title">received</span> <span class="title">message</span> <span class="title">from</span> <span class="type">JS</span>: %@", <span class="title">data</span>);</span><br><span class="line">        <span class="title">responseCallback</span>(@"<span class="type">Response</span> <span class="title">for</span> <span class="title">message</span> <span class="title">from</span> <span class="type">ObjC</span>");</span><br><span class="line">&#125;];</span></span><br></pre></td></tr></table></figure>
<h4 id="JS端："><a href="#JS端：" class="headerlink" title="JS端："></a>JS端：</h4><p>(以下是固定写法，你自己的JS文件中必须包含如下代码)</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectWebViewJavascriptBridge</span><span class="params">(callback)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">        <span class="keyword">callback</span>(WebViewJavascriptBridge)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        document.addEventListener(<span class="string">'WebViewJavascriptBridgeReady'</span>,   <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">callback</span>(WebViewJavascriptBridge)</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span><span class="params">(bridge)</span> </span>&#123;  </span><br><span class="line">    bridge.init(<span class="function"><span class="keyword">function</span><span class="params">(message, responseCallback)</span> </span>&#123;</span><br><span class="line">        log(<span class="string">'JS got a message'</span>, message)</span><br><span class="line">        <span class="keyword">var</span> data = &#123; <span class="string">'Javascript Responds'</span>:<span class="string">'Wee!'</span> &#125;</span><br><span class="line">        log(<span class="string">'JS responding with'</span>, data)</span><br><span class="line">        responseCallback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们要知道，在<code>WebViewJavascriptBridge</code>中，交互的方式只有两种：<code>send</code> 和 <code>callHandle</code>，JS和OC都有这两个方法，所以对应的四种关系是：<br><img src="http://kittenyang.com/content/images/2015/Aug/Screen-Shot-2015-08-02-at-01-35-51.png" alt=""></p>
<p>以上表中的对应关系的解读是，例如第一条：在JS中如果调用了<code>bridge.send()</code>，那么将触发OC端<strong>_bridge初始化方法中的回调</strong>。</p>
<p>同理，第二条，在JS中调用了<code>bridge.callHandler(&#39;testJavascriptHandler&#39;)</code>，它将触发OC端注册的同名方法:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bridge.registerHandler(<span class="string">'testJavascriptHandler'</span>, function(<span class="built_in">data</span>, responseCallback) &#123;  </span><br><span class="line">        <span class="keyword">log</span>(<span class="string">'ObjC called testJavascriptHandler with'</span>, <span class="built_in">data</span>)</span><br><span class="line">        <span class="built_in">var</span> responseData = &#123; <span class="string">'Javascript Says'</span>:<span class="string">'Right back atcha!'</span> &#125;</span><br><span class="line">        <span class="keyword">log</span>(<span class="string">'JS responding with'</span>, responseData)</span><br><span class="line">        responseCallback(responseData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>了解了使用规则，下面来看看在我们这个实际需求中应用的整体思路：</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/-----2015-08-07---3-14-34.png" alt=""></p>
<h3 id="–-1-–"><a href="#–-1-–" class="headerlink" title="– 1 –"></a>– 1 –</h3><p>首先，我们要做的第一步是替换获取的HTML文本中默认的<code>src</code>，以避免其会自动加载图片。</p>
<pre><code>NSString *_content = [contentstring stringByReplacingOccurrencesOfString:@&quot;src&quot; withString:@&quot;esrc&quot;];
</code></pre><h3 id="–-2-–"><a href="#–-2-–" class="headerlink" title="– 2 –"></a>– 2 –</h3><p>因为我们获取的只是HTML的body部分，因此我们需要自己书写完整的HTML。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"image.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"zepto.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"onLoaded()"</span>&gt;</span>  </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们让<code>&lt;body onload=&quot;onLoaded()&quot;&gt;</code>的时候去调用JS中的 <code>onLoaded()</code>函数。在这个函数中我们遍历所有img标签的 <code>esrc</code>，保存为一个数组返回给 OC 端，让native端去下载这些图片。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onLoaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> allImage = <span class="built_in">document</span>.querySelectorAll(<span class="string">"img"</span>);</span><br><span class="line">        allImage = <span class="built_in">Array</span>.prototype.slice.call(allImage, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">var</span> imageUrlsArray = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        allImage.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> esrc = image.getAttribute(<span class="string">"esrc"</span>);</span><br><span class="line">            <span class="keyword">var</span> newLength = imageUrlsArray.push(esrc);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        bridge.send(imageUrlsArray);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="–-3-–"><a href="#–-3-–" class="headerlink" title="– 3 –"></a>– 3 –</h3><p><code>bridge.send</code>会触发WebViewJavascriptBridge初始化方法 <code>+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler;</code>中的handler，我们在handler的block中下载所有图片。并且把下载完的图片在cache中的地址返回个JS。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark -- 下载全部图片</span></span><br><span class="line">-(<span class="keyword">void</span>)downloadAllImagesInNative:(<span class="built_in">NSArray</span> *)imageUrls&#123;</span><br><span class="line"></span><br><span class="line">    SDWebImageManager *manager = [SDWebImageManager sharedManager];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化一个置空元素数组</span></span><br><span class="line">    _allImagesOfThisArticle = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:imageUrls.count];<span class="comment">//本地的一个用于保存所有图片的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; imageUrls.count<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        [_allImagesOfThisArticle addObject:[<span class="built_in">NSNull</span> null]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; imageUrls.count<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *_url = imageUrls[i];</span><br><span class="line"></span><br><span class="line">        [manager downloadImageWithURL:[<span class="built_in">NSURL</span> URLWithString:_url] options:SDWebImageHighPriority progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">NSString</span> *imgB64 = [<span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>) base64EncodedStringWithOptions:<span class="built_in">NSDataBase64Encoding64CharacterLineLength</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把图片在磁盘中的地址传回给JS</span></span><br><span class="line">                    <span class="built_in">NSString</span> *key = [manager cacheKeyForURL:imageURL];</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">NSString</span> *source = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"data:image/png;base64,%@"</span>, imgB64];</span><br><span class="line">                    [_bridge callHandler:<span class="string">@"imagesDownloadComplete"</span> data:@[key,source]];</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="–-4-–"><a href="#–-4-–" class="headerlink" title="– 4 –"></a>– 4 –</h3><p><code>[_bridge callHandler:@&quot;imagesDownloadComplete&quot; data:@[key,source]]</code>会触发JS中的 <code>function imagesDownloadComplete()</code>。在这个函数中遍历所有img标签，把传过来的图片地址赋值给img的src。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">![]<span class="function"><span class="keyword">function</span> <span class="title">imagesDownloadComplete</span>(<span class="params">pOldUrl, pNewUrl</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> allImage = <span class="built_in">document</span>.querySelectorAll(<span class="string">"img"</span>);</span><br><span class="line">    allImage = <span class="built_in">Array</span>.prototype.slice.call(allImage, <span class="number">0</span>);</span><br><span class="line">    allImage.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (image.getAttribute(<span class="string">"esrc"</span>) == pOldUrl || image.getAttribute(<span class="string">"esrc"</span>) == <span class="built_in">decodeURIComponent</span>(pOldUrl)) &#123;</span><br><span class="line">            image.src = pNewUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>至此，通过<code>WebViewJavascriptBridge</code>处理UIWebView和JS交互实现本地处理网页图片的下载操作就基本完成了。这个例子展现了一个完整的过程，基本涉及了JS和OC的各种交互包括OC调用JS、JS调用OC等。如果你有其它的业务需求，也基本按照这个流程就可以依样画葫芦了，唯一不同的也就是业务逻辑了。</p>
<p>下面我再举一个例子。也是出现在我的业务需求里的，就是<strong>点击网页上的图片，图片会以Zoom-out的动画放大，左右滑动可以查看其它图片，同时还需要双击放大查看、保存图片等功能</strong>。 类似这样:</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/objs.gif" alt=""></p>
<p>乍一看，我们点击的是一张网页上的图片，怎么可能让这张图片单独跳出来？而且还能左右滑动显示其它图片？</p>
<p>首先我们还是需要去改造网络获取的那段HTML文本，正则匹配出<code>&lt;img esrc=http://....</code>,加上<code>onClick</code>事件，绑定一个JS的方法，并把这个esrc作为参数传入这个绑定的方法中。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正则替换</span></span><br><span class="line">NSRegularExpression *regex = [NSRegularExpression <span class="string">regularExpressionWithPattern:</span>@<span class="string">"(&lt;img[^&gt;]+esrc=\")(\\S+)\""</span> <span class="string">options:</span><span class="number">0</span> <span class="string">error:</span>nil];  </span><br><span class="line"> result = [regex <span class="string">stringByReplacingMatchesInString:</span>newContent <span class="string">options:</span><span class="number">0</span> <span class="string">range:</span>NSMakeRange(<span class="number">0</span>, newContent.length) <span class="string">withTemplate:</span>@<span class="string">"&lt;img esrc=\"$2\" onClick=\"javascript:onImageClick('$2')\""</span>];</span><br></pre></td></tr></table></figure>
<p>JS中<code>onImageClick()</code>函数。这个函数的主要任务是：<strong>获取点击图片的在所有图片中的编号以及在当前屏幕中的位置。并把这些信息返回给OC</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onImageClick</span>(<span class="params">picUrl</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> allImage = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p img[esrc]"</span>);</span><br><span class="line">        allImage = <span class="built_in">Array</span>.prototype.slice.call(allImage, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">var</span> urls = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> height = <span class="number">0</span>;</span><br><span class="line">        allImage.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> imgUrl = image.getAttribute(<span class="string">"esrc"</span>);</span><br><span class="line">            <span class="keyword">var</span> newLength = urls.push(imgUrl);</span><br><span class="line">            <span class="keyword">if</span>(imgUrl == picUrl || imgUrl == <span class="built_in">decodeURIComponent</span>(picUrl))&#123;</span><br><span class="line">                index = newLength<span class="number">-1</span>;</span><br><span class="line">                x = image.getBoundingClientRect().left;</span><br><span class="line">                y = image.getBoundingClientRect().top;</span><br><span class="line">                x = x + <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">                y = y + <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">                width = image.width;</span><br><span class="line">                height = image.height;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"x:"</span>+x +<span class="string">";y:"</span> + y+<span class="string">";width:"</span>+image.width +<span class="string">";height:"</span>+image.height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"检测到点击"</span>);</span><br><span class="line"></span><br><span class="line">        bridge.callHandler(<span class="string">'imageDidClicked'</span>, &#123;<span class="string">'index'</span>:index,<span class="string">'x'</span>:x,<span class="string">'y'</span>:y,<span class="string">'width'</span>:width,<span class="string">'height'</span>:height&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"JS已经发出imgurl和index，同时收到回调，说明OC已经收到数据"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bridge.callHandler</code> 会触发OC中的 <code>[_bridge registerHandler:@&quot;imageDidClicked&quot; handler:^(id data, WVJBResponseCallback responseCallback){}]</code>。我们可以再handler中获得JS传过来的点击图片在所有图片中的编号，以及点击图片在当前图片中的空间位置。要实现点击图片Zoom-out的效果，我们要善于「作弊」。网页中的图片固然不能「跳」出来放大，但我们可以根据JS传回来的x、y、width、height这些位置信息自己创建一个UIImageView,image和当前点击图片一致，设置透明度为0，add到UIWebView上面。并通过<a href="https://github.com/ideaismobile/IDMPhotoBrowser" target="_blank" rel="external">IDMPhotoBrowser</a> 这个开源库实现图片浏览。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[_bridge registerHandler:@<span class="string">"imageDidClicked"</span> handler:^(<span class="name">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line"></span><br><span class="line">    NSInteger index = [[data objectForKey:@<span class="string">"index"</span>] integerValue]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    CGFloat originX = [[data objectForKey:@<span class="string">"x"</span>] floatValue]<span class="comment">;</span></span><br><span class="line">    CGFloat originY = [[data objectForKey:@<span class="string">"y"</span>] floatValue]<span class="comment">;</span></span><br><span class="line">    CGFloat width   = [[data objectForKey:@<span class="string">"width"</span>] floatValue]<span class="comment">;</span></span><br><span class="line">    CGFloat height  = [[data objectForKey:@<span class="string">"height"</span>] floatValue]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    tappedImageView.alpha = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    tappedImageView.frame = CGRectMake(<span class="name">originX</span>, originY, width, height)<span class="comment">;</span></span><br><span class="line">    tappedImageView.image = _allImagesOfThisArticle[index]<span class="comment">;//_allImagesOfThisArticle是一个本地数组用来存放所有图片</span></span><br><span class="line"></span><br><span class="line">    NSLog(@<span class="string">"OC已经收到JS的imageDidClicked了: %@"</span>, data)<span class="comment">;</span></span><br><span class="line">    responseCallback(@<span class="string">"OC已经收到JS的imageDidClicked了"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    //点击放大图片</span><br><span class="line">    [self presentPhotosBrowserWithInitialPage:index animatedFromView:tappedImageView]<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>###Tips</p>
<p>由于我用的是<a href="http://www.sublimetext.com/3" target="_blank" rel="external">Sublime Text</a>,所以无法进行JS的调试。如果要用<a href="https://github.com/atom" target="_blank" rel="external">Atom</a>调试，又感觉有点小题大做。我就是想要有个地方可以轻松地看到是否打印出了<code>console.log</code>或者JS函数是否被调用了。始终相信，任何问题都是可以解决的。我们可以用Safari。</p>
<p>连上你的iPhone或者使用模拟器，当你的程序当前显示了一个UIWebView，Safari会自动识别这个UIWebview，并可以在<code>开发</code>菜单栏中找到你的设备进行调试。</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/-----2015-08-07---4-33-58.png" alt=""></p>
<p>选择<code>控制台</code>,你就可以看到久违的调试窗口以及JS的<code>console.log</code>了。</p>
<p><img src="http://kittenyang.com/content/images/2015/Aug/-----2015-08-07---4-36-30.png" alt=""></p>
<p>以上就是使用 <code>WebViewJavascriptBridge</code> 进行UIWebView与JS的深度交互的例子。</p>
<p>Node.JS都可以写服务器了，React Native都可以开发iOS了。学无止境，iOS应该先搞定OC和Swift再去搞前端。</p>
<p>参考：<a href="http://kittenyang.com/webview-javascript-bridge/" target="_blank" rel="external">UIWebView与JS的深度交互</a>         </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/iOS 优化界面流畅的技巧/" itemprop="url">
                  iOS 优化界面流畅的技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T21:42:46+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>date: 2016-05-18 21:42:46</p>
<h2 id="CPU-资源消耗原因和解决方案"><a href="#CPU-资源消耗原因和解决方案" class="headerlink" title="CPU 资源消耗原因和解决方案"></a>CPU 资源消耗原因和解决方案</h2><font color="#8FD228" size="3"> 对象创建 </font>


<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>
<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>
<font color="#8FD228" size="3"> 对象调整 </font>

<p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>
<font color="#8FD228" size="3"> 对象销毁 </font>


<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [tmp <span class="class"><span class="keyword">class</span>];</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
 <font color="#8FD228" size="3">  布局计算 </font>


<p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>
<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>
<font color="#8FD228" size="3"> Autolayout </font>


<p>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/" target="_blank" rel="external">http://pilky.me/36/</a>。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
<font color="#8FD228" size="3"> 文本计算 </font>


<p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：<br>用 </p>
<pre><code>[NSAttributedString boundingRectWithSize:options:context:] 
</code></pre><p>来计算文本宽高，用 </p>
<pre><code>-[NSAttributedString drawWithRect:options:context:] 
</code></pre><p>来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。<br>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<font color="#8FD228" size="3"> 文本渲染 </font>


<p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<font color="#8FD228" size="3"> 图片的解码 </font>


<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<font color="#8FD228" size="3"> 图像的绘制 </font>


<p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#8FD228" size="3">  GPU 资源消耗原因和解决方案 </font>


<p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>
<font color="#8FD228" size="3"> 纹理的渲染 </font>

<p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：<a href="iosres.com">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p>
<font color="#8FD228" size="3">  视图的混合(Composing) </font>

<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<font color="#8FD228" size="3"> 图形的生成 </font>

<p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<h2 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h2><h4 id="预排版"><a href="#预排版" class="headerlink" title="预排版"></a>预排版</h4><p>当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。</p>
<p>对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/" target="_blank" rel="external">FDTemplateLayoutCell</a>。</p>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。</p>
<p>对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。</p>
<h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><p>我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：<a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="external">YYAsyncLayer</a>。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。</p>
<p>当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。</p>
<p>目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。</p>
<h4 id="全局并发控制"><a href="#全局并发控制" class="headerlink" title="全局并发控制"></a>全局并发控制</h4><p>当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：</p>
<p>ios_dispatch_blocked_1 ios_dispatch_blocked_2</p>
<p>大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：SocialAppLayout，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。</p>
<p>使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 <a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="external">YYDispatchQueuePool</a>，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。</p>
<h4 id="更高效的异步图片加载"><a href="#更高效的异步图片加载" class="headerlink" title="更高效的异步图片加载"></a>更高效的异步图片加载</h4><p>SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。(- -太吊了)在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。</p>
<h4 id="其他可以改进的地方"><a href="#其他可以改进的地方" class="headerlink" title="其他可以改进的地方"></a>其他可以改进的地方</h4><p>上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：</p>
<p>列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。</p>
<p>再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。</p>
<p>目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。</p>
<p>把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。</p>
<h3 id="如何评测界面的流畅度"><a href="#如何评测界面的流畅度" class="headerlink" title="如何评测界面的流畅度"></a>如何评测界面的流畅度</h3><p>最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&gt; Profile -&gt; 修改代码这样一个流程，优先解决最值得优化的地方。</p>
<p>如果你需要一个明确的 FPS 指示器，可以尝试一下 <a href="https://github.com/kconner/KMCGeigerCounter" target="_blank" rel="external">KMCGeigerCounter</a>。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1x1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。</p>
<p>我自己也写了个简单的 FPS 指示器：<a href="https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m" target="_blank" rel="external">FPSLabel</a> 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。</p>
<p>最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。</p>
<p>参考：<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/UIView和CALayer/" itemprop="url">
                  UIView和CALayer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T18:07:01+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>UIView和CALayer都继承自NSObjet。</li>
</ul>
<h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><ul>
<li>UIView的继承结构为: UIResponder : NSObject。<ul>
<li>UIResponder是用来响应事件的，也就是UIView可以响应用户事件</li>
</ul>
</li>
<li>CALayer的继承结构为： NSObject<ul>
<li>直接从 NSObject继承，因为缺少了UIResponder类，所以CALayer悲催的不能响应任何用户事件。  </li>
</ul>
</li>
<li>UIView是视图的基类，UIViewController是视图控制器的基类，UIResponder是表示一个可以在屏幕上响应触摸事件的对象；</li>
</ul>
<h4 id="所属框架"><a href="#所属框架" class="headerlink" title="所属框架"></a>所属框架</h4><ul>
<li>UIView是在 /System/Library/Frameworks/UIKit.framework中定义的<ul>
<li>UIKit主要是用来构建用户界面，并且是可以响应事件的（源于UIView的父类UIResponder）</li>
<li>UIView是用来显示内容的，可以处理用户事件</li>
</ul>
</li>
<li>CALayer是在/System/Library/Frameworks/QuartzCore.framework定义的。<ul>
<li>CALayer作为一个低级的，可以承载绘制内容的底层对象出现在该框架中。</li>
<li>CALayer是用来绘制内容的，对内容进行动画处理依赖与UIView来进行显示，不能处理用户事件。</li>
</ul>
</li>
</ul>
<h4 id="作用机制"><a href="#作用机制" class="headerlink" title="作用机制"></a>作用机制</h4><ul>
<li><p>当UIView需要显示的时候，会调用drawRect：方法进行绘图，并且会将所有内容绘制在自己的图层上（CALayer上），系统将图层拷贝到屏幕上，完成UIView的显示。</p>
<ul>
<li>通过操作这个CALayer对象，可以很方便的调整UIView的一些界面属性，比如：阴影，圆角大小，旋转等等。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewT.layer.cornerRadius = <span class="number">10</span>;<span class="comment">//设置半径</span></span><br><span class="line">viewT.layer.borderWidth = <span class="number">10</span>;<span class="comment">//设置边框的宽度，当然可以不要</span></span><br><span class="line">viewT.layer.borderColor = [[<span class="built_in">UIColor</span> redColor] <span class="built_in">CGColor</span>];<span class="comment">//设置边框的颜色</span></span><br><span class="line">viewT.layer.masksToBounds = <span class="literal">YES</span>;<span class="comment">//设为NO去试试</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>所以UIView相比CALayer最大区别是UIView可以响应用户事件，而CALayer不可以。UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。</strong></p>
</li>
<li><p><strong>UIView和CALayer是相互依赖的关系。UIView依赖与CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力。</strong></p>
</li>
<li><strong>UIView来自CALayer，高于CALayer，是CALayer的高层实现与封装。UIView的所有特性来源于CALayer支持。</strong></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/14/单元测试/" itemprop="url">
                  单元测试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-14T23:50:28+08:00" content="2016-05-14">
              2016-05-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在计算机编程中，<strong>单元测试</strong>（英语：Unit Testing）又称为<strong>模块测试</strong>, 是针对程序模块的最小单位来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 – 维基百科</p>
<p>使用单元测试以后，我们就没必要为了测试某个小模块去编译我们的程序，然后去等待模拟器启动然后到你需要验证的模块去。如果项目很大，编译要等很长时间</p>
<p>####单元测试能节约我们的时间，提高开发效率，对于项目越大的效果越明显。</p>
<p>###XCTest<br>XCode4.x时代Xcode集成的是<strong>OCUnit</strong>，到了XCode5.x时代就升级为了<strong>XCTest</strong>,并且到了XCode7时代还有了进行UI测试的能力。除了官方自带的，还有一些比较出名的第三方的测试框架，如：GHUnit,KiWi，OCMock,Specta等,当然本文不讨论这些第三方框架。怎么知道我们的项目有没有加上单元测试，用Xcode打开你的项目，看文件导航栏有没有类似下图的两个文件夹（TestDemo是工程名）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-3e92ba680ba3a3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mou icon"></p>
<p>其实在我们新建工程的时候就可以为我们的工程选择是否带上单元测试，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-6ea5e9824aac3772.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果你的项目没有上面说的两个文件，你可以通过新建一个Target的方式添加，如下图：<br>就是给项目添加测试TARGETS</p>
<p>方法1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-640964197cbf1fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>方法2<br><img src="http://upload-images.jianshu.io/upload_images/465386-4ea67ede8f12800f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这2个文件夹目录下分别都有2个文件，一个.m文件和一个plist文件。并且.m文件有4个方法，如下：</p>
<p>测试文件名称自定义，可以删除自己创建，注意要继承自XCTestCase<br>通过Xcode的File-&gt;New-&gt;File-&gt;Source选择Unit Test Case Class来新建一个UserTests,注意要继承XCTestCase类。</p>
<p>项目名+Test的.m文件里面默认有4个方法，这个文件里面主要做一些逻辑的测试。项目名+UITest的.m文件里默认有3个方法。这个文件里面主要做一些UI的测试。</p>
<p>在讲解如何写测试方法前，先说说默认的方法的作用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  MZToolsTest.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MZToolsTest</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MZToolsTest</span></span></span><br><span class="line"><span class="comment">//每个test方法执行前调用，在这个测试用例里进行一些通用的初始化工作</span></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">   [<span class="keyword">super</span> setUp];</span><br><span class="line">   <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个test方法执行后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">   <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">   [<span class="keyword">super</span> tearDown];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试方法样例</span></span><br><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line">   <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">   <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法主要是做性能测试的，所谓性能测试，主要就是评估一段代码的运行时间。该方法就是性能测试方法的样例。</span></span><br><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">   <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">   [<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">       <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>测试用例方法非常简单，从testExample这个方法我们大概知道怎么写了，方法名只需要以test开头，是的，就是这么简单。<br>现在我们模拟登录这个功能来写一个登录模块的测试用例</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface User : NSObject

@property (nonatomic, copy) NSString *userName;
@property (nonatomic, copy) NSString *passWord;

/**
 *  判断字符串中是否有中文
 */
- (BOOL)isChinese:(NSString *)string;

@end
</code></pre><p>现在我们通过Xcode的File-&gt;New-&gt;File-&gt;Source选择Unit Test Case Class来新建一个UserTests,注意要继承XCTestCase类。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-46c15939c20c31fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来我们为User类写一个测试isChinese方法的测试方法，叫做testIsChinese,测试用例具体如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/465386-aeb21b3114c57784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这样，你只要点击测试方法旁边的那个菱形的按钮就可以运行该测试方法！通过测试会变成绿色的对勾，失败会变成红色的叉叉。到这里测试用例你就会写了。也许你会在意那些断言，这样的断言有18个，如下</p>
<pre><code>XCTFail(format…)  //生成一个失败的测试；
XCTAssertNil(a1, format...)  //为空判断，a1为空时通过，反之不通过；
XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；
XCTAssert(expression, format...) //当expression求值为TRUE时通过；
XCTAssertTrue(expression, format...) //当expression求值为TRUE时通过；
XCTAssertFalse(expression, format...)  //当expression求值为False时通过；
XCTAssertEqualObjects(a1, a2, format...)  //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；
XCTAssertNotEqualObjects(a1, a2, format...)  //判断不等，[a1 isEqual:a2]值为False时通过；
XCTAssertEqual(a1, a2, format...)  //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；
XCTAssertNotEqual(a1, a2, format...)  //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；

XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)  //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；

XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...)   //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；

XCTAssertThrows(expression, format...)  //异常测试，当expression发生异常时通过；反之不通过；

XCTAssertThrowsSpecific(expression, specificException, format...)  //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；

XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；

XCTAssertNoThrow(expression, format…)  //异常测试，当expression没有发生异常时通过测试；

XCTAssertNoThrowSpecific(expression, specificException, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；

XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过
</code></pre><p>UI测试稍后更新…..</p>
<p>###总结<br>这只是苹果官方集成在Xcode中的简单框架，优点就是简单，缺点也是简单。当然它的用法也绝非如此，有很多还待开发。苹果官方也有一个Demo，地址点击这里</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/hello-world/" itemprop="url">
                  Hello Hexo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:43:54+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<p>###基本命令  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>###图片方案</p>
<p>hexo 下插入图片现在大概有几个方案</p>
<p>1.1 放在根目录</p>
<p>早期大部分的方案是把图片放在 source/img 下，然后在 markdown 里写 <code>![img](/source/img/img.png)</code>。显然这样在本地的编辑器里完全不能正确识别图片的位置。</p>
<p>1.2 asset-image</p>
<p>在 hexo 2.x 时出现的插件，后来被吸纳进 <code>hexo 3 core</code> ，用法的介绍见 <a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="external">资源文件夹 | Hexo</a> 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。</p>
<p>2 解决方案</p>
<pre><code>[CodeFalling/hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)
</code></pre><p>2.1 使用</p>
<p>首先确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。</p>
<p>在 hexo 目录，执行</p>
<pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save
</code></pre><p>假设在</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MacGesture2-Publish</span><br><span class="line">├── apppicker<span class="selector-class">.jpg</span></span><br><span class="line">├── logo<span class="selector-class">.jpg</span></span><br><span class="line">└── rules.jpg</span><br></pre></td></tr></table></figure>
<p>MacGesture2-Publish.md<br>这样的目录结构（目录名和文章名一致），只要使用 <img src="MacGesture2-Publish/logo.jpg" alt="logo"> 就可以插入图片。</p>
<p>生成的结构为</p>
<p>public/2015/10/18/MacGesture2-Publish<br>├── apppicker.jpg<br>├── index.html<br>├── logo.jpg<br>└── rules.jpg<br>同时，生成的 html 是</p>
<pre><code>&lt;img src=&quot;/2015/10/18/MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt;
</code></pre><p>而不是愚蠢的</p>
<pre><code>&lt;img src=&quot;MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt;
</code></pre><p>值得一提的是，这个插件对于 <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">CodeFalling/hexo-renderer-org</a> 同样有效。</p>
<p>参考：<a href="http://www.tuicool.com/articles/umEBVfI" target="_blank" rel="external">在 hexo 中无痛使用本地图片</a></p>
<p><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">MK语法</a></p>
<p><a href="http://baixin.io/2016/03/01/iOSNote/" target="_blank" rel="external">iOS Develop</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhumuzhi" />
          <p class="site-author-name" itemprop="name">zhumuzhi</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhumuzhi</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
